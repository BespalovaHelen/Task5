# MyShell

### Реализовано:
**Команды** `ls`, `cat`, `cd`, `pwd`, Запуск исполняемых файлов
**Перенаправление** `<`, `>`, `>>` 
**Конвейеры** Множественные `|` 
**Фоновый режим** `&`
**Разделители** `;`, `&&`, `||` 
**Скобочки** `()` - подпроцессы 
**Кавычки** `"` - строки с пробелами
**Чтение из файла**

### Мой Shell состоит из 4 модулей:
- main.c          - Точка входа, управление вводом/выводом, обработка сигналов
- parser.h
- parser.c        - Лексический, синтаксический анализ, разделение на токены, обработка кавычек
- executor.h
- executor.c      - Выполнение команд (fork, exec), управление процессами, конвейеры, перенаправление, фоновый режим  
- utils.h
- utils.c         - Вспомогательные функции, управление памятью
- Makefile        - Сборка

## Основные функции

### `main()` - Точка входа

1. Устанавливает обработчик сигналов
2. Определяет источник ввода (stdin или файл)
3. Вызывает `InputAndPrint()` для запуска основного цикла
4. Закрывает файлы при завершении

### InputAndPrint() - Главный цикл ввода
Чтение команд, отображение приглашения, управление основным циклом shell.

Алгоритм работы:
Пока (не конец файла):
   1. Очистка зомби-процессов (waitpid)
   2. Показ приглашения с текущей директорией
   3. Чтение строки через Inp_Str()
   4. Разбор строки через Processing_String()
   5. Подготовка к выполнению через prepare_for_execution()
   6. Освобождение памяти

### Inp_Str() - Чтение строки с клавиатуры
Динамическое чтение строки произвольной длины.

Выделить начальный буфер, читать посимвольно до \n или EOF, при необходимости увеличивать буфер, вернуть готовую строку

### Processing_String() - Лексический анализ
Разбиение строки  с учетом кавычек и спецсимволов.

Обрабатывает:
  1. Обычные слова: ls, -la, file.txt
  2. Спецсимволы: |, &, >, <, ;
  3. Двойные символы: &&, ||, >>
  4. Кавычки: "строка с пробелами"
  5. Скобки: (, )

Логика работы:
   - Если внутри кавычек: добавить символ к текущему слову
   - Если спецсимвол: сохранить предыдущее слово, начать новое
   - Если пробел: разделить слова
   - Иначе: добавить символ к слову


### prepare_for_execution() - Диспетчер команд
Разделение команд по операторам ;, &&, || и управление их выполнением.

Логика работы:
    Находит операторы вне скобок
    Отслеживает баланс скобочек для правильного разделения
    Логика операторов:
        &&: выполнить следующую только если текущая успешна
        ||: выполнить следующую только если текущая неуспешна
        ;: всегда выполнить следующую


### execution_line() - Выполнитель команд
Основная функция выполнения одной команды или группы.

Основные шаги:
1. Проверить фоновые процессы
2. Удалить пустые аргументы (compact_args)
3. Проверить встроенные команды (cd)
4. Создать дочерний процесс (fork)
5. В дочернем:
   - Настроить перенаправления (i_o_redirection)
   - Проверить конвейеры (is_there_conveyor)
   - Выполнить команду (execvp)
6. В родительском:
   - Для фоновых: продолжить сразу
   - Для обычных: ждать завершения (waitpid)


### i_o_redirection() - Перенаправление потоков
Обработка операторов <, >, >>.

Находит >, <, открывает файл с нужными флагами, перенаправляет файловый дескриптор через dup2() и удаляет оператор и имя файла из аргументов


### is_there_conveyor() и conveyor_n_processes() - Конвейеры
  Подсчитывает количество команд в конвейере
  Заменяет | на NULL в массиве для разделения команд


### is_there_background_process() - Фоновый режим
Обработка оператора &.

Находит & в массиве аргументов, подсчитывает количество, (должен быть максимум один)
Помечает & как NULL для удаления в compact_args()
Возвращает 1 если есть &, 0 если нет

### rid_of_brackets() - Обработка скобок
Назначение: Удаление скобок и рекурсивное выполнение содержимого.

Алгоритм:
1. Удалить открывающую скобку "(" (заменить на NULL)
2. Сдвинуть все элементы на 1 позицию влево
3. Найти и удалить закрывающую скобку ")"
4. Создать новый массив только с содержимым скобок
5. Рекурсивно вызвать prepare_for_execution() для содержимого

### free_memory() и compact_args() - Управление памятью
